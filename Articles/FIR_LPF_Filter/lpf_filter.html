<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="shortcut icon" type="image/png" href="../fav.png" />

    <meta charset="UTF-8">
    <title>Designing &amp; Implementing a Finite Impulse Response (FIR) Low Pass Filter (LPF)</title>
    <p style="padding-left: 60px; padding-right: 60px;"><a href="c_notes_3.html">Bootstrapped Page </a></p>

</head>

<body>
    <div style="padding-left: 60px; padding-right: 60px;">

        <h1 id="designing-implementing-a-finite-impulse-response-fir-low-pass-filter-lpf-">Designing &amp; Implementing
            a
            Finite
            Impulse Response (FIR) Low Pass Filter (LPF)</h1>
        <b><em><i> By Tony Josi</i></em></b>
        <p>Often in different applications, noisy signals are to be filtered using software filters to enhance the
            signal
            quality and remove the noise content. This article aims at designing and implementing a finite impulse
            response
            low
            pass filter using the simple moving average approach by deriving an approximation relation between the
            filter's
            cut-off frequency and the window size of the moving average.</p>
        <p><a href="https://en.wikipedia.org/wiki/Finite_impulse_response"><strong>Finite Impulse Response
                    (FIR)</strong></a>
            filters are those filters that have a fixed number of non zero output values when given an impulse signal as
            input.
            Compared to the Infinite  impulse  response filters, FIRs are phase linear and uses convolution instead of
            recursion.
            Using <a href="https://www.dspguide.com/ch6/2.htm"><strong>Convolution</strong></a> the output signal is
            obtained as
            the convolution of the input signal and the impulse  response <a
                href="https://www.dspguide.com/ch6/2.htm">[more]</a>. <a
                href="https://en.wikipedia.org/wiki/Impulse_response"><strong> impulse response</strong></a> of a filter
            is
            the
            response or output of the filter when it's fed with an impulse signal.</p>
        <h3 id="filter-design-approach">Filter Design Approach</h3>
        <p>The relation between cutoff frequency and the window size (block size) of the MA Filter can be obtained by
            analysing
            the response produced by the filter (of any window size, say N) when an impulsesignal is passed through it.
            Since
            the impulse function contains all frequencies, the impulse response defines the response of a linear
            time-invariant
            system for all frequencies <a href="https://en.wikipedia.org/wiki/Impulse_response">[more]</a>. The impulse
            response
            of MA Filter will look like a &quot;box&quot; as the average (window size N) of impulse amplitude is taken
            as
            the
            amplitude of the output until the number of samples reaches from 0 to N, if the impulse occurs at the sample
            zero in
            the
            input signal. The <a href="https://en.wikipedia.org/wiki/Discrete-time_Fourier_transform"><strong>Discrete
                    Time
                    Fourier Transform (DTFT)</strong></a> of the output signal of the filter reveals the frequency
            characteristics of the filter (Frequency response).</p>
        <p>To find the cut off frequency of a filter of Window size N, equate the frequency response function of the
            filter
            at
            cut-off frequency to 1/sqrt(2) (ie, -3 dB); as the <strong>cut-off frequency</strong> is regarded as the
            frequency
            at which the filter <strong>reduces the amplitude of the input signal</strong> by 1/sqrt(2) [-3 dB]. That means
            if a
            signal of frequency equal to cut-off frequency enters the filter, then the filter reduces the amplitude of
            the
            signal by 1/sqrt(2).</p>
        <h3 id="deriving-the-frequency-response-of-a-moving-average-filter">Deriving the Frequency Response of a Moving
            Average
            Filter</h3>
        <h4 id="impluse-response">impulseResponse</h4>
        <table>
            <thead>
                <tr>
                    <th style="text-align:center"><img
                            src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/impulse.png?raw=true"
                            alt="Impulse Signal"></th>
                    <th style="text-align:center"><img
                            src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/imp_resp_plot.png?raw=true"
                            alt="Impulse Response"></th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="text-align:center">Impulse Signal</td>
                    <td style="text-align:center">Impulse Response</td>
                </tr>
            </tbody>
        </table>
        <p>The above image (right) shows the response of an impulse signal at 40, through an FIR LPF filter of window size
            9.
        </p>
        <p>If <strong>N</strong> is the window size of the LPF filter, then the impulse response of the filter can be
            defined
            as:</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/imp_resp.png?raw=true"
                alt="1"></p>
        <p><strong>OR:</strong></p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/imp_resp_1.png?raw=true"
                alt="2"></p>
        <h4 id="discrete-time-fourier-transform-of-impulse-signal">Discrete Time Fourier Transform of Impulse Signal
        </h4>
        <p>The frequency response of the filter should be taken to analyse the filter characteristics. The discrete time
            fourier
            transform of the output signal of the filter reveals the frequency characteristics of the filter. Discrete
            time
            fourier transform can be obtained using the following equation,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft.png?raw=true"
                alt="1">
        </p>
        <p>Replacing the input signal with the impulse response signal,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_2.png?raw=true"
                alt="1">
        </p>
        <p>The summation (sigma term) in the above equation can be considered as the sum of a geometric series. </p>
        <blockquote>
            <p>The sum of a geometric series <img
                    src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/gs_1.svg?raw=true"
                    alt="1"> can be defined as, <img
                    src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/gs_2svg.svg?raw=true"
                    alt="1"> <a href="https://en.wikipedia.org/wiki/Geometric_progression">[refer]</a></p>
        </blockquote>
        <p>So the summation can be expressed as,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_3.png?raw=true"
                alt="1">
        </p>
        <p>Then the frequency response becomes,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_4.png?raw=true"
                alt="1">
        </p>
        <blockquote>
            <p><strong>Eulers Formula:</strong>
                From Eulers Formula, <img
                    src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_5.png?raw=true"
                    alt="1">, <a href="https://en.wikipedia.org/wiki/Euler%27s_formula">[refer]</a></p>
        </blockquote>
        <p>Replacing with Eulers Formula,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_6.png?raw=true"
                alt="1">
        </p>
        <p>As we are only interested in the magnitude of the filter response and not it's phase, we can leave out the
            exponents
            from the above equation and use the remaining part for the analysis of frequency response,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_7.png?raw=true"
                alt="1">
        </p>
        <p>So the above function defines the response amplitude of a signal of frequency ω, when passed through the
            filter.
            The
            cut-off frequency is defined as the frequency at which the energy of the signal reduces by −3 dB. Hence the
            amplitude at the cut-off frequency will be -3 dB * amplitude of input signal. -3 dB = 1/sqrt(2);</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_8.png?raw=true"
                alt="1">
        </p>
        <p>The above equation havent got any simple analytical solution. One method to approximate solutions for the
            above
            equation is to use <a href="https://en.wikipedia.org/wiki/Taylor_series"><strong>Taylor Series</strong></a>
            representation of <strong>F(ωc)</strong>.</p>
        <p>If we approximate the <strong>F(ωc)</strong> to the first 3 orders/terms of the Taylor Series,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_9.png?raw=true"
                alt="1">
        </p>
        <p><a
                href="https://www.wolframalpha.com/input/?i=taylor+series+calculator&amp;assumption=%7B%22F%22%2C+%22TaylorSeries%22%2C+%22taylorVariable%22%7D+-%3E%22x%22&amp;assumption=%7B%22F%22%2C+%22TaylorSeries%22%2C+%22taylorFunction%22%7D+-%3E%22sin%28N*%CF%89%29%2F%28Nsin%28%CF%89%29%29%22&amp;assumption=%7B%22F%22%2C+%22TaylorSeries%22%2C+%22taylorPoint%22%7D+-%3E%220%22&amp;assumption=%7B%22F%22%2C+%22TaylorSeries%22%2C+%22taylorOrder%22%7D+-%3E%223%22">[Refer]</a>
            for the detailed steps of Taylor Series approximation of <strong>F(ω)</strong>.</p>
        <p>Taking the first two terms of the above Taylor Series Approximation gives us,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_10.png?raw=true"
                alt="1"></p>
        <p>Solving the above equation,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_11.png?raw=true"
                alt="1"></p>
        <p>Even though above equation connects the window size and cut-off frequency the equation is biased, meaning
            that
            the
            approximation error doesnt converge at large values of window size, N. To avoid that, one method is to
            generalise
            the above equation by replacing the constant with a variable <code>a</code>; </p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_15.png?raw=true"
                alt="1"> </p>
        <p>and substituting it in the frequency response and equating it to 1/sqrt(2) when limit N tends to infinity,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_12.png?raw=true"
                alt="1"></p>
        <p>the above limit leads to,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_13.png?raw=true"
                alt="1"></p>
        <p><a
                href="https://www.wolframalpha.com/input/?i=limit+calculator&amp;assumption=%7B%22F%22%2C+%22Limit%22%2C+%22limit%22%7D+-%3E%22Infinity%22&amp;assumption=%7B%22F%22%2C+%22Limit%22%2C+%22limitfunction%22%7D+-%3E%22sin%28%28xa%29%2F%282Sqrt%28x%5E2-1%29%29%29%22">[Refer
                1]</a> for the detailed steps of Limit Calculation.</p>
        <p><a
                href="https://www.wolframalpha.com/input/?i=limit+calculator&amp;assumption=%7B%22F%22%2C+%22Limit%22%2C+%22limit%22%7D+-%3E%22Infinity%22&amp;assumption=%7B%22F%22%2C+%22Limit%22%2C+%22limitfunction%22%7D+-%3E%22x*sin%28%28a%29%2F%282Sqrt%28x%5E2-1%29%29%29%22">[Refer
                2]</a> for the detailed steps of Limit Calculation.</p>
        <p>Solving the above equation gives,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_14.png?raw=true"
                alt="1"></p>
        <p>Replacing the above new constant in the cut-off frequency - window size equation gives,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_16.png?raw=true"
                alt="1"></p>
        <p>Converting continuous time frequency ω to the discrete time frequency f, where fs is the sampling frequency,
        </p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_17.png?raw=true"
                alt="1"></p>
        <p>Substituting the above equation becomes,</p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_18.png?raw=true"
                alt="1"></p>
        <p>Finally, for a particular cut-off frequency <strong>f</strong>, window size <strong>N</strong> can be
            expressed
            as,
        </p>
        <p><img src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/dtft_19.png?raw=true"
                alt="1"></p>
        <p>where fs is the sampling frequency.</p>
        <h3 id="fir-lpf-filter-implemented-in-software">FIR LPF Filter Implemented in Software</h3>
        <p>The below C++ code snippet implements an FIR LPF filter using the simple moving average approach:</p>
        <pre><code class="lang-C++"><span class="hljs-keyword">class</span> fir_lpf_MA_Filter {

    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">int</span>         moving_Avg_Length;
        <span class="hljs-keyword">double</span>      lpf_Sum;
        <span class="hljs-keyword">double</span>     *data_Buffer;
        <span class="hljs-keyword">int</span>         buffer_NotFilled;
        <span class="hljs-keyword">int</span>         data_Buffer_Cur_Length;

    <span class="hljs-keyword">public</span>:
        fir_lpf_MA_Filter(<span class="hljs-keyword">double</span> cut_Off_Freq, <span class="hljs-keyword">double</span> sampling_Freq);
        <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">fir_lpf_MA_Filter_Process</span><span class="hljs-params">(<span class="hljs-keyword">double</span> data)</span></span>;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fir_lpf_MA_Filter_Reset</span><span class="hljs-params">()</span></span>;
        ~fir_lpf_MA_Filter();

        fir_lpf_MA_Filter(<span class="hljs-keyword">const</span> fir_lpf_MA_Filter &amp;copy) = <span class="hljs-keyword">delete</span>;
        fir_lpf_MA_Filter <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> fir_lpf_MA_Filter &amp;copy) = <span class="hljs-keyword">delete</span>;
        fir_lpf_MA_Filter(fir_lpf_MA_Filter &amp;&amp;copy) = <span class="hljs-keyword">delete</span>;
        fir_lpf_MA_Filter <span class="hljs-keyword">operator</span>=(fir_lpf_MA_Filter &amp;&amp;copy) = <span class="hljs-keyword">delete</span>;

};

fir_lpf_MA_Filter::fir_lpf_MA_Filter(<span class="hljs-keyword">double</span> cut_Off_Freq, <span class="hljs-keyword">double</span> sampling_Freq) {

    <span class="hljs-keyword">auto</span> fCut_Off = cut_Off_Freq / sampling_Freq;
    <span class="hljs-keyword">auto</span> temp_bs = fCut_Off * fCut_Off;
    moving_Avg_Length = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">0.196202</span> + temp_bs) / fCut_Off;
    data_Buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[moving_Avg_Length]();
    data_Buffer_Cur_Length = <span class="hljs-number">0</span>;
    lpf_Sum = <span class="hljs-number">0</span>;
    buffer_NotFilled = <span class="hljs-number">1</span>;

}

fir_lpf_MA_Filter::~fir_lpf_MA_Filter() {

    <span class="hljs-keyword">delete</span>[] data_Buffer;

}

<span class="hljs-keyword">double</span> fir_lpf_MA_Filter::fir_lpf_MA_Filter_Process(<span class="hljs-keyword">double</span> data) {

    lpf_Sum += data;
    data_Buffer[data_Buffer_Cur_Length] = data;
    <span class="hljs-keyword">if</span>(++data_Buffer_Cur_Length == moving_Avg_Length) {
        data_Buffer_Cur_Length = <span class="hljs-number">0</span>;
        buffer_NotFilled = <span class="hljs-number">0</span>;
    } 
    lpf_Sum -= data_Buffer[data_Buffer_Cur_Length];
    <span class="hljs-keyword">return</span> buffer_NotFilled ? lpf_Sum / data_Buffer_Cur_Length : lpf_Sum / moving_Avg_Length;

}

<span class="hljs-keyword">void</span> fir_lpf_MA_Filter::fir_lpf_MA_Filter_Reset() {

    <span class="hljs-built_in">std</span>::fill_n(data_Buffer, moving_Avg_Length, <span class="hljs-number">0.0</span>);
    buffer_NotFilled = <span class="hljs-number">0</span>;
    data_Buffer_Cur_Length = <span class="hljs-number">0</span>;

}
</code></pre>
        <h3 id="examples">Examples</h3>
        <p>The following example shows an unfiltered input signal (left) having 2 frequencies: 1 error signal at 1.2 Hz
            and
            1
            data signal of 0.01 Hz, when passed to the LPF filter with a cut-off frequency of 0.025 Hz produces the
            filtered
            signal (right) with only the data signal of 0.01 Hz frequency.</p>
        <table>
            <thead>
                <tr>
                    <th style="text-align:center"><img
                            src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/unfiltered.png?raw=true"
                            alt="Unfiltered Input Signal"></th>
                    <th style="text-align:center"><img
                            src="https://github.com/TonyJosi97/profile/blob/master/Articles/FIR_LPF_Filter/res/filtered.png?raw=true"
                            alt="Filtered Output Signal"></th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="text-align:center">Unfiltered Input Signal</td>
                    <td style="text-align:center">Filtered Output Signal</td>
                </tr>
            </tbody>
        </table>

    </div>

</body>

</html>